<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Xiao Cheng</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://smiletolove.github.io/"/>
  <updated>2019-03-05T05:43:51.340Z</updated>
  <id>https://smiletolove.github.io/</id>
  
  <author>
    <name>Xiao Cheng</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>gitalk评论插件在Hexo中的应用</title>
    <link href="https://smiletolove.github.io/2019/03/03/gitalk%E8%AF%84%E8%AE%BA%E6%8F%92%E4%BB%B6%E5%9C%A8hexo%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8.1/"/>
    <id>https://smiletolove.github.io/2019/03/03/gitalk评论插件在hexo中的应用.1/</id>
    <published>2019-03-03T06:20:22.000Z</published>
    <updated>2019-03-05T05:43:51.340Z</updated>
    
    <content type="html"><![CDATA[<h2 id="gitalk简介"><a href="#gitalk简介" class="headerlink" title="gitalk简介"></a>gitalk简介</h2><p>Gitalk 是一个基于 GitHub Issue 和 Preact 开发的评论插件。<br>项目地址：<a href="https://github.com/gitalk/gitalk" target="_blank" rel="noopener">https://github.com/gitalk/gitalk</a></p><p><image src="/css/images/表情/两把刷子.gif" style="display:block;margin:40px auto 0;"><a id="more"></a></image></p><h2 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h2><p>使用 GitHub 登录<br>支持多语言（en, zh-CN, zh-TW, es-ES, fr, ru）<br>支持个人或组织<br>无干扰模式（设置 distractionFreeMode 为 true 开启）<br>快捷键提交评论 （cmd|ctrl + enter）</p><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p>想要gitalk，需要申请<a href="https://github.com/settings/applications/new" target="_blank" rel="noopener">GitHub Application</a>。</p><p>如上图，以此为例：</p><p>Application name填入喜欢的应用名称。<br>Homepage URL填入域名。<br>Application description填入应用的描述。<br>Authorization callback URL 填入域名。<br>然后，Register application，转到<a href="https://github.com/settings/developers" target="_blank" rel="noopener">应用页面</a>。在该页面，可以看到Client ID和Client Secret。</p><h2 id="使用配置"><a href="#使用配置" class="headerlink" title="使用配置"></a>使用配置</h2><p>以yilia主题为例。</p><p>1、下载gitalk项目<br>git clone <a href="https://github.com/gitalk/gitalk.git" target="_blank" rel="noopener">https://github.com/gitalk/gitalk.git</a></p><p>2、拷贝gitalk/dist/目录下的gitalk.css和gitalk.min.js到yilia/source/lib/gitalk目录。</p><p>3、在yilia/layout/_partial/post目录下，新建gittalk.ejs，内容为：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=<span class="string">"gitalk"</span>&gt;</span><br><span class="line">    &lt;div id=<span class="string">"gitalk-container"</span>&gt;&lt;/div&gt;</span><br><span class="line">    &lt;script <span class="built_in">type</span>=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line">        const gitalk = new Gitalk(&#123;</span><br><span class="line">            clientID: <span class="string">'&lt;%=theme.gitalk.client_id%&gt;'</span>,</span><br><span class="line">            clientSecret: <span class="string">'&lt;%=theme.gitalk.client_secret%&gt;'</span>,</span><br><span class="line">            repo: <span class="string">'&lt;%=theme.gitalk.repo%&gt;'</span>,</span><br><span class="line">            owner: <span class="string">'&lt;%=theme.gitalk.owner%&gt;'</span>,</span><br><span class="line">            admin: [<span class="string">'&lt;%=theme.gitalk.admin%&gt;'</span>],</span><br><span class="line">            id: location.pathname,      // Ensure uniqueness and length less than 50</span><br><span class="line">            distractionFreeMode: <span class="literal">false</span>  // Facebook-like distraction free mode</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">        gitalk.render(<span class="string">'gitalk-container'</span>)</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p><p>4、编辑yilia/layout/_partial/article.ejs，添加：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;% <span class="keyword">if</span> (!index &amp;&amp; theme.gitalk.enable &amp;&amp; post.comments)&#123; %&gt;</span><br><span class="line">&lt;%- partial(<span class="string">'post/gitalk'</span>, &#123;</span><br><span class="line">    key: post.slug,</span><br><span class="line">    title: post.title,</span><br><span class="line">    url: config.url+url_for(post.path)</span><br><span class="line">  &#125;) %&gt;</span><br><span class="line">&lt;% &#125; %&gt;</span><br></pre></td></tr></table></figure></p><p>5、编辑yilia/_config.yml，添加：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 注释所有畅言配置</span></span><br><span class="line"><span class="comment"># 配置gitalk</span></span><br><span class="line">gitalk: </span><br><span class="line">  <span class="built_in">enable</span>: <span class="literal">true</span></span><br><span class="line">  client_id: 5a238b8c32b1e4dd2156</span><br><span class="line">  client_secret: bfb5d518626f6fdc7da0351d1e0cd37ab75c6361</span><br><span class="line">  repo: voidking.github.io</span><br><span class="line">  owner: voidking</span><br><span class="line">  admin: voidking</span><br></pre></td></tr></table></figure></p><p>6、编辑yilia/layout/_partial/head.ejs，添加：</p><pre><code class="bash">&lt;% <span class="keyword">if</span> (theme.gitalk.enable){ %&gt;  &lt;link rel=<span class="string">"stylesheet"</span> href=<span class="string">"/lib/gitalk/gitalk.css"</span>&gt;  &lt;script src=<span class="string">"/lib/gitalk/gitalk.min.js"</span>&gt;&lt;/script&gt;&lt;% } %&gt;至此，配置gitalk评论插件完成。</code></pre><h2 id="最终效果如下图："><a href="#最终效果如下图：" class="headerlink" title="最终效果如下图："></a>最终效果如下图：</h2><p><img src="/css/images/gitalk.jpg" alt><!--- more ---></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;gitalk简介&quot;&gt;&lt;a href=&quot;#gitalk简介&quot; class=&quot;headerlink&quot; title=&quot;gitalk简介&quot;&gt;&lt;/a&gt;gitalk简介&lt;/h2&gt;&lt;p&gt;Gitalk 是一个基于 GitHub Issue 和 Preact 开发的评论插件。&lt;br&gt;项目地址：&lt;a href=&quot;https://github.com/gitalk/gitalk&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/gitalk/gitalk&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;image src=&quot;/css/images/表情/两把刷子.gif&quot; style=&quot;display:block;margin:40px auto 0;&quot;&gt;
    
    </summary>
    
    
      <category term="gitalk评论插件" scheme="https://smiletolove.github.io/tags/gitalk%E8%AF%84%E8%AE%BA%E6%8F%92%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>AMD与CMD的区别</title>
    <link href="https://smiletolove.github.io/2019/02/09/AMD%E4%B8%8ECMD%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>https://smiletolove.github.io/2019/02/09/AMD与CMD的区别/</id>
    <published>2019-02-09T14:14:14.000Z</published>
    <updated>2019-03-05T05:58:31.009Z</updated>
    
    <content type="html"><![CDATA[<h2 id="AMD"><a href="#AMD" class="headerlink" title="AMD"></a>AMD</h2><p>AMD 即Asynchronous Module Definition，中文名是异步模块定义的意思。它是一个在浏览器端模块化开发的规范.</p><p>由于不是JavaScript原生支持，使用AMD规范进行页面开发需要用到对应的库函数，也就是大名鼎鼎RequireJS，实际上AMD 是 RequireJS 在推广过程中对模块定义的规范化的产出.<a id="more"></a></p><p>requireJS主要解决两个问题</p><p>  1.多个js文件可能有依赖关系，被依赖的文件需要早于依赖它的文件加载到浏览器<br>  2.js加载的时候浏览器会停止页面渲染，加载文件越多，页面失去响应时间越长</p><p>看一个使用requireJS的例子</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// 定义模块 myModule.js</span><br><span class="line">define([<span class="string">'dependency'</span>], <span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">    var name = <span class="string">'Byron'</span>;</span><br><span class="line">    <span class="keyword">function</span> <span class="function"><span class="title">printName</span></span>()&#123;</span><br><span class="line">        console.log(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">return</span> &#123;</span><br><span class="line">        printName: printName</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// 加载模块</span><br><span class="line">require([<span class="string">'myModule'</span>], <span class="keyword">function</span> (my)&#123;</span><br><span class="line">　 my.printName();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><p>requireJS定义了一个函数 define，它是全局变量，用来定义模块</p><p>define(id?, dependencies?, factory);<br>  1.id：可选参数，用来定义模块的标识，如果没有提供该参数，脚本文件名（去掉拓展名）<br>  2.dependencies：是一个当前模块依赖的模块名称数组<br>  3.factory：工厂方法，模块初始化要执行的函数或对象。如果为函数，它应该只被执行一次。如果是对象，此对象应该为模块的输出值<br>在页面上使用require函数加载模块</p><p>require([dependencies], function(){});<br>require()函数接受两个参数</p><p>第一个参数是一个数组，表示所依赖的模块<br>第二个参数是一个回调函数，当前面指定的模块都加载成功后，它将被调用。加载的模块会以参数形式传入该函数，从而在回调函数内部就可以使用这些模块<br>require()函数在加载依赖的函数的时候是异步加载的，这样浏览器不会失去响应，它指定的回调函数，只有前面的模块都加载成功后，才会运行，解决了依赖性的问题。</p><h2 id="CMD"><a href="#CMD" class="headerlink" title="CMD"></a>CMD</h2><p>CMD 即Common Module Definition通用模块定义，CMD规范是国内发展出来的，就像AMD有个requireJS，CMD有个浏览器的实现SeaJS，SeaJS要解决的问题和requireJS一样，只不过在模块定义方式和模块加载（可以说运行、解析）时机上有所不同</p><h3 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h3><p>Sea.js 推崇一个模块一个文件，遵循统一的写法</p><h3 id="define"><a href="#define" class="headerlink" title="define"></a>define</h3><p>define(id?, deps?, factory)<br>因为CMD推崇<br>  1.一个文件一个模块，所以经常就用文件名作为模块id<br>  2.CMD推崇依赖就近，所以一般不在define的参数中写依赖，在factory中写<br>  factory有三个参数</p><p>function(require, exports, module)</p><h3 id="require"><a href="#require" class="headerlink" title="require"></a>require</h3><p>require 是 factory 函数的第一个参数</p><p>require(id)<br>require 是一个方法，接受 模块标识 作为唯一参数，用来获取其他模块提供的接口</p><h3 id="exports"><a href="#exports" class="headerlink" title="exports"></a>exports</h3><p>exports 是一个对象，用来向外提供模块接口</p><h3 id="module"><a href="#module" class="headerlink" title="module"></a>module</h3><p>module 是一个对象，上面存储了与当前模块相关联的一些属性和方法</p><h2 id="demo"><a href="#demo" class="headerlink" title="demo"></a>demo</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 定义模块  myModule.js</span><br><span class="line">define(<span class="keyword">function</span>(require, exports, module) &#123;</span><br><span class="line">  var $ = require(<span class="string">'jquery.js'</span>)</span><br><span class="line">  $(<span class="string">'div'</span>).addClass(<span class="string">'active'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// 加载模块</span><br><span class="line">seajs.use([<span class="string">'myModule.js'</span>], <span class="keyword">function</span>(my)&#123;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="AMD与CMD区别"><a href="#AMD与CMD区别" class="headerlink" title="AMD与CMD区别"></a>AMD与CMD区别</h2><p>关于这两个的区别网上可以搜出一堆文章，简单总结一下</p><p>最明显的区别就是在模块定义时对依赖的处理不同</p><p>  1.AMD推崇依赖前置，在定义模块的时候就要声明其依赖的模块<br>  2.CMD推崇就近依赖，只有在用到某个模块的时候再去require<br>  这种区别各有优劣，只是语法上的差距，而且requireJS和SeaJS都支持对方的写法</p><p>AMD和CMD最大的区别是对依赖模块的执行时机处理不同，注意不是加载的时机或者方式不同</p><p>很多人说requireJS是异步加载模块，SeaJS是同步加载模块，这么理解实际上是不准确的，其实加载模块都是异步的，只不过AMD依赖前置，js可以方便知道依赖模块是谁，立即加载，而CMD就近依赖，需要使用把模块变为字符串解析一遍才知道依赖了那些模块，这也是很多人诟病CMD的一点，牺牲性能来带来开发的便利性，实际上解析模块用的时间短到可以忽略</p><p>为什么我们说两个的区别是依赖模块执行时机不同，为什么很多人认为ADM是异步的，CMD是同步的（除了名字的原因。。。）</p><p>同样都是异步加载模块，AMD在加载模块完成后就会执行改模块，所有模块都加载执行完后会进入require的回调函数，执行主逻辑，这样的效果就是依赖模块的执行顺序和书写顺序不一定一致，看网络速度，哪个先下载下来，哪个先执行，但是主逻辑一定在所有依赖加载完成后才执行</p><p>CMD加载完某个依赖模块后并不执行，只是下载而已，在所有依赖模块加载完成后进入主逻辑，遇到require语句的时候才执行对应的模块，这样模块的执行顺序和书写顺序是完全一致的</p><p>这也是很多人说AMD用户体验好，因为没有延迟，依赖模块提前执行了，CMD性能好，因为只有用户需要的时候才执行的原因</p><p>转自[<a href="https://www.cnblogs.com/futai/p/5258349.html]https://www.cnblogs.com/futai/p/5258349.html" target="_blank" rel="noopener">https://www.cnblogs.com/futai/p/5258349.html]https://www.cnblogs.com/futai/p/5258349.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;AMD&quot;&gt;&lt;a href=&quot;#AMD&quot; class=&quot;headerlink&quot; title=&quot;AMD&quot;&gt;&lt;/a&gt;AMD&lt;/h2&gt;&lt;p&gt;AMD 即Asynchronous Module Definition，中文名是异步模块定义的意思。它是一个在浏览器端模块化开发的规范.&lt;/p&gt;
&lt;p&gt;由于不是JavaScript原生支持，使用AMD规范进行页面开发需要用到对应的库函数，也就是大名鼎鼎RequireJS，实际上AMD 是 RequireJS 在推广过程中对模块定义的规范化的产出.
    
    </summary>
    
    
      <category term="AMD" scheme="https://smiletolove.github.io/tags/AMD/"/>
    
      <category term="CMD" scheme="https://smiletolove.github.io/tags/CMD/"/>
    
  </entry>
  
  <entry>
    <title>闭包</title>
    <link href="https://smiletolove.github.io/2019/01/02/%E9%97%AD%E5%8C%85/"/>
    <id>https://smiletolove.github.io/2019/01/02/闭包/</id>
    <published>2019-01-01T16:18:39.000Z</published>
    <updated>2019-03-05T05:56:40.366Z</updated>
    
    <content type="html"><![CDATA[<p>闭包是函数和声明该函数的词法环境的组合。</p><p>词法作用域节<a id="more"></a><br>考虑如下情况：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">init</span></span>() &#123;</span><br><span class="line">    var name = <span class="string">"Mozilla"</span>; // name 是一个被 init 创建的局部变量</span><br><span class="line">    <span class="keyword">function</span> <span class="function"><span class="title">displayName</span></span>() &#123; // displayName() 是内部函数,一个闭包</span><br><span class="line">        alert(name); // 使用了父函数中声明的变量</span><br><span class="line">    &#125;</span><br><span class="line">    displayName();</span><br><span class="line">&#125;</span><br><span class="line">init();</span><br></pre></td></tr></table></figure></p><p>init() 创建了一个局部变量 name 和一个名为 displayName() 的函数。displayName() 是定义在 init() 里的内部函数，仅在该函数体内可用。displayName() 内没有自己的局部变量，然而它可以访问到外部函数的变量，所以 displayName() 可以使用父函数 init() 中声明的变量 name 。但是，如果有同名变量 name 在 displayName() 中被定义，则会使用 displayName() 中定义的 name 。</p><p>运行代码可以发现 displayName() 内的 alert() 语句成功的显示了在其父函数中声明的 name 变量的值。这个词法作用域的例子介绍了引擎是如何解析函数嵌套中的变量的。词法作用域中使用的域，是变量在代码中声明的位置所决定的。嵌套的函数可以访问在其外部声明的变量。</p><h3 id="闭包节"><a href="#闭包节" class="headerlink" title="闭包节"></a>闭包节</h3><p>现在来考虑如下例子 ：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">makeFunc</span></span>() &#123;</span><br><span class="line">    var name = <span class="string">"Mozilla"</span>;</span><br><span class="line">    <span class="keyword">function</span> <span class="function"><span class="title">displayName</span></span>() &#123;</span><br><span class="line">        alert(name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> displayName;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var myFunc = makeFunc();</span><br><span class="line">myFunc();</span><br></pre></td></tr></table></figure></p><p>运行这段代码和之前的 init() 示例的效果完全一样。其中的不同 — 也是有意思的地方 — 在于内部函数 displayName() 在执行前，被外部函数返回。</p><p>第一眼看上去，也许不能直观的看出这段代码能够正常运行。在一些编程语言中，函数中的局部变量仅在函数的执行期间可用。一旦 makeFunc() 执行完毕，我们会认为 name 变量将不能被访问。然而，因为代码运行得没问题，所以很显然在 JavaScript 中并不是这样的。</p><p>这个谜题的答案是，JavaScript中的函数会形成闭包。 闭包是由函数以及创建该函数的词法环境组合而成。这个环境包含了这个闭包创建时所能访问的所有局部变量。在我们的例子中，myFunc 是执行 makeFunc 时创建的 displayName 函数实例的引用，而 displayName 实例仍可访问其词法作用域中的变量，即可以访问到 name 。由此，当 myFunc 被调用时，name 仍可被访问，其值 Mozilla 就被传递到alert中。</p><p>下面是一个更有意思的示例 — makeAdder 函数：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> makeAdder(x) &#123;</span><br><span class="line">  <span class="built_in">return</span> <span class="keyword">function</span>(y) &#123;</span><br><span class="line">    <span class="built_in">return</span> x + y;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var add5 = makeAdder(5);</span><br><span class="line">var add10 = makeAdder(10);</span><br><span class="line"></span><br><span class="line">console.log(add5(2));  // 7</span><br><span class="line">console.log(add10(2)); // 12</span><br></pre></td></tr></table></figure></p><p>在这个示例中，我们定义了 makeAdder(x) 函数，它接受一个参数 x ，并返回一个新的函数。返回的函数接受一个参数 y，并返回x+y的值。</p><p>从本质上讲，makeAdder 是一个函数工厂 — 他创建了将指定的值和它的参数相加求和的函数。在上面的示例中，我们使用函数工厂创建了两个新函数 — 一个将其参数和 5 求和，另一个和 10 求和。</p><p>add5 和 add10 都是闭包。它们共享相同的函数定义，但是保存了不同的词法环境。在 add5 的环境中，x 为 5。而在 add10 中，x 则为 10。</p><p>实用的闭包节<br>闭包很有用，因为它允许将函数与其所操作的某些数据（环境）关联起来。这显然类似于面向对象编程。在面向对象编程中，对象允许我们将某些数据（对象的属性）与一个或者多个方法相关联。</p><p>因此，通常你使用只有一个方法的对象的地方，都可以使用闭包。<br>在 Web 中，你想要这样做的情况特别常见。大部分我们所写的 JavaScript 代码都是基于事件的 — 定义某种行为，然后将其添加到用户触发的事件之上（比如点击或者按键）。我们的代码通常作为回调：为响应事件而执行的函数。</p><p>假如，我们想在页面上添加一些可以调整字号的按钮。一种方法是以像素为单位指定 body 元素的 font-size，然后通过相对的 em 单位设置页面中其它元素（例如header）的字号：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">body &#123;</span><br><span class="line">  font-family: Helvetica, Arial, sans-serif;</span><br><span class="line">  font-size: 12px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">h1 &#123;</span><br><span class="line">  font-size: 1.5em;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">h2 &#123;</span><br><span class="line">  font-size: 1.2em;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们的文本尺寸调整按钮可以修改 body 元素的 font-size 属性，由于我们使用相对单位，页面中的其它元素也会相应地调整。</p><p>以下是 JavaScript：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> makeSizer(size) &#123;</span><br><span class="line">  <span class="built_in">return</span> <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">    document.body.style.fontSize = size + <span class="string">'px'</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var size12 = makeSizer(12);</span><br><span class="line">var size14 = makeSizer(14);</span><br><span class="line">var size16 = makeSizer(16);</span><br></pre></td></tr></table></figure></p><p>size12，size14 和 size16 三个函数将分别把 body 文本调整为 12，14，16 像素。我们可以将它们分别添加到按钮的点击事件上。如下所示：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">document.getElementById(<span class="string">'size-12'</span>).onclick = size12;</span><br><span class="line">document.getElementById(<span class="string">'size-14'</span>).onclick = size14;</span><br><span class="line">document.getElementById(<span class="string">'size-16'</span>).onclick = size16;</span><br><span class="line">&lt;a href=<span class="string">"#"</span> id=<span class="string">"size-12"</span>&gt;12&lt;/a&gt;</span><br><span class="line">&lt;a href=<span class="string">"#"</span> id=<span class="string">"size-14"</span>&gt;14&lt;/a&gt;</span><br><span class="line">&lt;a href=<span class="string">"#"</span> id=<span class="string">"size-16"</span>&gt;16&lt;/a&gt;</span><br></pre></td></tr></table></figure></p><h3 id="用闭包模拟私有方法节"><a href="#用闭包模拟私有方法节" class="headerlink" title="用闭包模拟私有方法节"></a>用闭包模拟私有方法节</h3><p>编程语言中，比如 Java，是支持将方法声明为私有的，即它们只能被同一个类中的其它方法所调用。</p><p>而 JavaScript 没有这种原生支持，但我们可以使用闭包来模拟私有方法。私有方法不仅仅有利于限制对代码的访问：还提供了管理全局命名空间的强大能力，避免非核心的方法弄乱了代码的公共接口部分。</p><p>下面的示例展现了如何使用闭包来定义公共函数，并令其可以访问私有函数和变量。这个方式也称为 模块模式（module pattern）：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">var Counter = (<span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">  var privateCounter = 0;</span><br><span class="line">  <span class="keyword">function</span> changeBy(val) &#123;</span><br><span class="line">    privateCounter += val;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">return</span> &#123;</span><br><span class="line">    increment: <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">      changeBy(1);</span><br><span class="line">    &#125;,</span><br><span class="line">    decrement: <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">      changeBy(-1);</span><br><span class="line">    &#125;,</span><br><span class="line">    value: <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">      <span class="built_in">return</span> privateCounter;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;   </span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line">console.log(Counter.value()); /* logs 0 */</span><br><span class="line">Counter.increment();</span><br><span class="line">Counter.increment();</span><br><span class="line">console.log(Counter.value()); /* logs 2 */</span><br><span class="line">Counter.decrement();</span><br><span class="line">console.log(Counter.value()); /* logs 1 */</span><br></pre></td></tr></table></figure></p><p>在之前的示例中，每个闭包都有它自己的词法环境；而这次我们只创建了一个词法环境，为三个函数所共享：Counter.increment，Counter.decrement 和 Counter.value。</p><p>该共享环境创建于一个立即执行的匿名函数体内。这个环境中包含两个私有项：名为 privateCounter 的变量和名为 changeBy 的函数。这两项都无法在这个匿名函数外部直接访问。必须通过匿名函数返回的三个公共函数访问。</p><p>这三个公共函数是共享同一个环境的闭包。多亏 JavaScript 的词法作用域，它们都可以访问 privateCounter 变量和 changeBy 函数。</p><p>你应该注意到我们定义了一个匿名函数，用于创建一个计数器。我们立即执行了这个匿名函数，并将他的值赋给了变量counter。我们可以把这个函数储存在另外一个变量makeCounter中，并用他来创建多个计数器。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">var makeCounter = <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">  var privateCounter = 0;</span><br><span class="line">  <span class="keyword">function</span> changeBy(val) &#123;</span><br><span class="line">    privateCounter += val;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">return</span> &#123;</span><br><span class="line">    increment: <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">      changeBy(1);</span><br><span class="line">    &#125;,</span><br><span class="line">    decrement: <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">      changeBy(-1);</span><br><span class="line">    &#125;,</span><br><span class="line">    value: <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">      <span class="built_in">return</span> privateCounter;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;  </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var Counter1 = makeCounter();</span><br><span class="line">var Counter2 = makeCounter();</span><br><span class="line">console.log(Counter1.value()); /* logs 0 */</span><br><span class="line">Counter1.increment();</span><br><span class="line">Counter1.increment();</span><br><span class="line">console.log(Counter1.value()); /* logs 2 */</span><br><span class="line">Counter1.decrement();</span><br><span class="line">console.log(Counter1.value()); /* logs 1 */</span><br><span class="line">console.log(Counter2.value()); /* logs 0 */</span><br></pre></td></tr></table></figure></p><p>请注意两个计数器 counter1 和 counter2 是如何维护它们各自的独立性的。每个闭包都是引用自己词法作用域内的变量 privateCounter 。</p><p>每次调用其中一个计数器时，通过改变这个变量的值，会改变这个闭包的词法环境。然而在一个闭包内对变量的修改，不会影响到另外一个闭包中的变量。</p><p>以这种方式使用闭包，提供了许多与面向对象编程相关的好处 —— 特别是数据隐藏和封装。</p><p>在循环中创建闭包：一个常见错误节<br>在 ECMAScript 2015 引入 let 关键字 之前，在循环中有一个常见的闭包创建问题。参考下面的示例：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&lt;p id=<span class="string">"help"</span>&gt;Helpful notes will appear here&lt;/p&gt;</span><br><span class="line">&lt;p&gt;E-mail: &lt;input <span class="built_in">type</span>=<span class="string">"text"</span> id=<span class="string">"email"</span> name=<span class="string">"email"</span>&gt;&lt;/p&gt;</span><br><span class="line">&lt;p&gt;Name: &lt;input <span class="built_in">type</span>=<span class="string">"text"</span> id=<span class="string">"name"</span> name=<span class="string">"name"</span>&gt;&lt;/p&gt;</span><br><span class="line">&lt;p&gt;Age: &lt;input <span class="built_in">type</span>=<span class="string">"text"</span> id=<span class="string">"age"</span> name=<span class="string">"age"</span>&gt;&lt;/p&gt;</span><br><span class="line"><span class="keyword">function</span> showHelp(<span class="built_in">help</span>) &#123;</span><br><span class="line">  document.getElementById(<span class="string">'help'</span>).innerHTML = <span class="built_in">help</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">setupHelp</span></span>() &#123;</span><br><span class="line">  var helpText = [</span><br><span class="line">      &#123;<span class="string">'id'</span>: <span class="string">'email'</span>, <span class="string">'help'</span>: <span class="string">'Your e-mail address'</span>&#125;,</span><br><span class="line">      &#123;<span class="string">'id'</span>: <span class="string">'name'</span>, <span class="string">'help'</span>: <span class="string">'Your full name'</span>&#125;,</span><br><span class="line">      &#123;<span class="string">'id'</span>: <span class="string">'age'</span>, <span class="string">'help'</span>: <span class="string">'Your age (you must be over 16)'</span>&#125;</span><br><span class="line">    ];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (var i = 0; i &lt; helpText.length; i++) &#123;</span><br><span class="line">    var item = helpText[i];</span><br><span class="line">    document.getElementById(item.id).onfocus = <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">      showHelp(item.help);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">setupHelp();</span><br></pre></td></tr></table></figure></p><p>数组 helpText 中定义了三个有用的提示信息，每一个都关联于对应的文档中的input 的 ID。通过循环这三项定义，依次为相应input添加了一个 onfocus  事件处理函数，以便显示帮助信息。</p><p>运行这段代码后，您会发现它没有达到想要的效果。无论焦点在哪个input上，显示的都是关于年龄的信息。</p><p>原因是赋值给 onfocus 的是闭包。这些闭包是由他们的函数定义和在 setupHelp 作用域中捕获的环境所组成的。这三个闭包在循环中被创建，但他们共享了同一个词法作用域，在这个作用域中存在一个变量item。当onfocus的回调执行时，item.help的值被决定。由于循环在事件触发之前早已执行完毕，变量对象item（被三个闭包所共享）已经指向了helpText的最后一项。</p><p>解决这个问题的一种方案是使用更多的闭包：特别是使用前面所述的函数工厂：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> showHelp(<span class="built_in">help</span>) &#123;</span><br><span class="line">  document.getElementById(<span class="string">'help'</span>).innerHTML = <span class="built_in">help</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> makeHelpCallback(<span class="built_in">help</span>) &#123;</span><br><span class="line">  <span class="built_in">return</span> <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">    showHelp(<span class="built_in">help</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">setupHelp</span></span>() &#123;</span><br><span class="line">  var helpText = [</span><br><span class="line">      &#123;<span class="string">'id'</span>: <span class="string">'email'</span>, <span class="string">'help'</span>: <span class="string">'Your e-mail address'</span>&#125;,</span><br><span class="line">      &#123;<span class="string">'id'</span>: <span class="string">'name'</span>, <span class="string">'help'</span>: <span class="string">'Your full name'</span>&#125;,</span><br><span class="line">      &#123;<span class="string">'id'</span>: <span class="string">'age'</span>, <span class="string">'help'</span>: <span class="string">'Your age (you must be over 16)'</span>&#125;</span><br><span class="line">    ];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (var i = 0; i &lt; helpText.length; i++) &#123;</span><br><span class="line">    var item = helpText[i];</span><br><span class="line">    document.getElementById(item.id).onfocus = makeHelpCallback(item.help);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">setupHelp();</span><br></pre></td></tr></table></figure></p><p>这段代码可以如我们所期望的那样工作。所有的回调不再共享同一个环境， makeHelpCallback 函数为每一个回调创建一个新的词法环境。在这些环境中，help 指向 helpText 数组中对应的字符串。</p><p>另一种方法使用了匿名闭包：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> showHelp(<span class="built_in">help</span>) &#123;</span><br><span class="line">  document.getElementById(<span class="string">'help'</span>).innerHTML = <span class="built_in">help</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">setupHelp</span></span>() &#123;</span><br><span class="line">  var helpText = [</span><br><span class="line">      &#123;<span class="string">'id'</span>: <span class="string">'email'</span>, <span class="string">'help'</span>: <span class="string">'Your e-mail address'</span>&#125;,</span><br><span class="line">      &#123;<span class="string">'id'</span>: <span class="string">'name'</span>, <span class="string">'help'</span>: <span class="string">'Your full name'</span>&#125;,</span><br><span class="line">      &#123;<span class="string">'id'</span>: <span class="string">'age'</span>, <span class="string">'help'</span>: <span class="string">'Your age (you must be over 16)'</span>&#125;</span><br><span class="line">    ];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (var i = 0; i &lt; helpText.length; i++) &#123;</span><br><span class="line">    (<span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">       var item = helpText[i];</span><br><span class="line">       document.getElementById(item.id).onfocus = <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">         showHelp(item.help);</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;)(); // 马上把当前循环项的item与事件回调相关联起来</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">setupHelp();</span><br></pre></td></tr></table></figure></p><p>避免使用过多的闭包，可以用let关键词：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> showHelp(<span class="built_in">help</span>) &#123;</span><br><span class="line">  document.getElementById(<span class="string">'help'</span>).innerHTML = <span class="built_in">help</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">setupHelp</span></span>() &#123;</span><br><span class="line">  var helpText = [</span><br><span class="line">      &#123;<span class="string">'id'</span>: <span class="string">'email'</span>, <span class="string">'help'</span>: <span class="string">'Your e-mail address'</span>&#125;,</span><br><span class="line">      &#123;<span class="string">'id'</span>: <span class="string">'name'</span>, <span class="string">'help'</span>: <span class="string">'Your full name'</span>&#125;,</span><br><span class="line">      &#123;<span class="string">'id'</span>: <span class="string">'age'</span>, <span class="string">'help'</span>: <span class="string">'Your age (you must be over 16)'</span>&#125;</span><br><span class="line">    ];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (var i = 0; i &lt; helpText.length; i++) &#123;</span><br><span class="line">    <span class="built_in">let</span> item = helpText[i];</span><br><span class="line">    document.getElementById(item.id).onfocus = <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">      showHelp(item.help);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">setupHelp();</span><br></pre></td></tr></table></figure></p><p>这个例子使用let而不是var，因此每个闭包都绑定了块作用域的变量，这意味着不再需要额外的闭包。</p><p>性能考量节<br>如果不是某些特定任务需要使用闭包，在其它函数中创建函数是不明智的，因为闭包在处理速度和内存消耗方面对脚本性能具有负面影响。</p><p>例如，在创建新的对象或者类时，方法通常应该关联于对象的原型，而不是定义到对象的构造器中。原因是这将导致每次构造器被调用时，方法都会被重新赋值一次（也就是，每个对象的创建）。</p><p>考虑以下示例：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> MyObject(name, message) &#123;</span><br><span class="line">  this.name = name.toString();</span><br><span class="line">  this.message = message.toString();</span><br><span class="line">  this.getName = <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">    <span class="built_in">return</span> this.name;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  this.getMessage = <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">    <span class="built_in">return</span> this.message;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在上面的代码中，我们并没有利用到闭包的好处，因此可以避免使用闭包。修改成如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> MyObject(name, message) &#123;</span><br><span class="line">  this.name = name.toString();</span><br><span class="line">  this.message = message.toString();</span><br><span class="line">&#125;</span><br><span class="line">MyObject.prototype = &#123;</span><br><span class="line">  getName: <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">    <span class="built_in">return</span> this.name;</span><br><span class="line">  &#125;,</span><br><span class="line">  getMessage: <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">    <span class="built_in">return</span> this.message;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>但我们不建议重新定义原型。可改成如下例子：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> MyObject(name, message) &#123;</span><br><span class="line">  this.name = name.toString();</span><br><span class="line">  this.message = message.toString();</span><br><span class="line">&#125;</span><br><span class="line">MyObject.prototype.getName = <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">  <span class="built_in">return</span> this.name;</span><br><span class="line">&#125;;</span><br><span class="line">MyObject.prototype.getMessage = <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">  <span class="built_in">return</span> this.message;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>在前面的两个示例中，继承的原型可以为所有对象共享，不必在每一次创建对象时定义方法。参见 对象模型的细节 一章可以了解更为详细的信息。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;闭包是函数和声明该函数的词法环境的组合。&lt;/p&gt;
&lt;p&gt;词法作用域节
    
    </summary>
    
      <category term="js" scheme="https://smiletolove.github.io/categories/js/"/>
    
    
      <category term="闭包" scheme="https://smiletolove.github.io/tags/%E9%97%AD%E5%8C%85/"/>
    
  </entry>
  
  <entry>
    <title>彻底搞懂js原型链</title>
    <link href="https://smiletolove.github.io/2018/11/01/%E5%BD%BB%E5%BA%95%E6%90%9E%E6%87%82js%E5%8E%9F%E5%9E%8B%E9%93%BE/"/>
    <id>https://smiletolove.github.io/2018/11/01/彻底搞懂js原型链/</id>
    <published>2018-11-01T15:54:06.000Z</published>
    <updated>2019-03-05T05:57:38.214Z</updated>
    
    <content type="html"><![CDATA[<h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><p>要清楚原型链,首先要弄清楚对象：</p><p>普通对象<br>最普通的对象：有<strong>proto</strong>属性（指向其原型链），没有prototype属性。<br>原型对象(person.prototype 原型对象还有constructor属性（指向构造函数对象）)<image src="/css/images/表情/好期待.gif" style="display:block;margin:20px auto 0;"><a id="more"></a><br>函数对象：<br>凡是通过new Function()创建的都是函数对象。<br>拥有<strong>proto</strong>、prototype属性（指向原型对象）。<br>Function、Object、Array、Date、String、自定义函数<br>特例： Function.prototype(是原型对象，却是函数对象，下面会有解释)<br>函数对象<br>function f1(){};<br>var f2 = function(){};<br>var f3 = function(“n1”,”n2”,”return n1+n2”);</image></p><p>console.log(typeof f1);  //function<br>console.log(typeof f2);  //function<br>console.log(typeof f3);   //function<br>console.log(typeof Object);   //function<br>console.log(typeof Array);   //function<br>console.log(typeof String);   //function<br>console.log(typeof Date);   //function<br>console.log(typeof Function);   //function</p><p>Array是函数对象，是Function的实例对象，Array是通过newFunction创建出来的。因为Array是Function的实例，所以Array.<strong>proto</strong> ===  Function.prototype</p><h2 id="普通对象"><a href="#普通对象" class="headerlink" title="普通对象"></a>普通对象</h2><p>var o1 = new f1();<br>var o2 = {};<br>var o3 = new Object(); </p><p>console.log(typeof o1);  //Object<br>console.log(typeof o2);   //Object<br>console.log(typeof o3);   //Object</p><h2 id="原型对象"><a href="#原型对象" class="headerlink" title="原型对象"></a>原型对象</h2><p>每创建一个函数都会有一个prototype属性，这个属性是一个指针，指向一个对象（通过该构造函数创建实例对象的原型对象）。原型对象是包含特定类型的所有实例共享的属性和方法。原型对象的好处是，可以让所有实例对象共享它所包含的属性和方法。<br>第一块中有提到，原型对象属于普通对象。Function.prototype是个例外，它是原型对象，却又是函数对象，作为一个函数对象，它又没有prototype属性。<br>function person(){};</p><p>console.log(typeof person.prototype) //Object<br>console.log(typeof Object.prototype) // Object<br>console.log(typeof Function.prototype) // 特殊 Function<br>console.log(typeof Function.prototype.prototype) //undefined 函数对象却没有prototype属性<br>解释：<br>functionperson(){};<br>其实原型对象就是构造函数的一个实例对象。person.prototype就是person的一个实例对象。相当于在person创建的时候，自动创建了一个它的实例，并且把这个实例赋值给了prototype。</p><p> function person(){};<br>var temp = new person();<br>person.prototype = temp;</p><p>function Function(){};<br>var temp = new Function();<br>Function.prototype = temp; //由new Function()产生的对象都是函数对象</p><p>看懂原型对象、构造函数、实例对象之间的关系:</p><p>function Dog(){};</p><p>Dog.prototype.name = “小黄”;<br>Dog.prototype.age =  13;<br>Dog.prototype.getAge = function(){<br>    return this.age;<br>}</p><p>var dog1 = new Dog();<br>var dog2 = new Dog();</p><p>dog2.name = “小黑”;<br>console.log(dog1.name); // 小黄 来自原型<br>console.log(dog2.name); // 小黑 来自实例<br><img src="/css/images/js原型链/js原型链.jpg" alt><br>//图中的一些关系<br>dog1.<strong>proto</strong> === Dog.prototype</p><p>Dog.prototype.<strong>proto</strong> === Object.prototype //继承Object 下面原型链说</p><p>dog1.<strong>proto</strong>.<strong>proto</strong> === Object.prototype</p><p>Dog.prototype.constructor === Dog </p><p>Dog.prototype.isPrototypeOf(dog1)</p><p>获取对象的原型<br>dog1.<strong>proto</strong>  //不推荐<br>Object.getPrototypeOf(dog1) === Dog.prototype   //推荐</p><h2 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h2><p>原型链是实现继承的主要方法。</p><p>先说一下继承，许多OO语言都支持两张继承方式：接口继承、实现继承。</p><p>|- 接口继承：只继承方法签名</p><p>|- 实现继承：继承实际的方法</p><p>由于函数没有签名，在ECMAScript中无法实现接口继承，只支持实现继承，而实现继承主要是依靠原型链来实现。</p><p>原型链基本思路：<br><img src="/css/images/js原型链/思路.jpg" alt><br>利用原型让一个引用类型继承另一个引用类型的属性和方法。</p><p>每个构造函数都有一个原型对象，原型对象都包含一个指向构造函数想指针(constructor)，而实例对象都包含一个指向原型对象的内部指针(<strong>proto</strong>)。如果让原型对象等于另一个类型的实例，此时的原型对象将包含一个指向另一个原型的指针(<strong>proto</strong>)，另一个原型也包含着一个指向另一个构造函数的指针(constructor)。假如另一个原型又是另一个类型的实例……这就构成了实例与原型的链条。</p><p>原型链基本思路（图解）：</p><p>举例说明：</p><p>function animal(){<br>    this.type = “animal”;<br>}<br>animal.prototype.getType = function(){<br>    return this.type;<br>}</p><p>function dog(){<br>    this.name = “dog”;<br>}<br>dog.prototype = new animal();</p><p>dog.prototype.getName = function(){<br>    return this.name;<br>}</p><p>var xiaohuang = new dog();</p><p> //原型链关系<br>xiaohuang.<strong>proto</strong> === dog.prototype<br>dog.prototype.<strong>proto</strong> === animal.prototype<br>animal.prototype.<strong>proto</strong> === Object.prototype<br>Object.prototype.<strong>proto</strong> === null</p><p>图解:<br><img src="/css/images/js原型链/图解.jpg" alt></p><p>详细图<br><img src="/css/images/js原型链/详细图.jpg" alt></p><p>从xiaohuang这个实例，看出整个链条</p><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p><img src="/css/images/js原型链/总结.jpg" alt><br>Xiaohuang这个Dog的实例对象继承了Animal，Animal继承了Object。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;对象&quot;&gt;&lt;a href=&quot;#对象&quot; class=&quot;headerlink&quot; title=&quot;对象&quot;&gt;&lt;/a&gt;对象&lt;/h2&gt;&lt;p&gt;要清楚原型链,首先要弄清楚对象：&lt;/p&gt;
&lt;p&gt;普通对象&lt;br&gt;最普通的对象：有&lt;strong&gt;proto&lt;/strong&gt;属性（指向其原型链），没有prototype属性。&lt;br&gt;原型对象(person.prototype 原型对象还有constructor属性（指向构造函数对象）)&lt;image src=&quot;/css/images/表情/好期待.gif&quot; style=&quot;display:block;margin:20px auto 0;&quot;&gt;
    
    </summary>
    
      <category term="js" scheme="https://smiletolove.github.io/categories/js/"/>
    
    
      <category term="js原型链" scheme="https://smiletolove.github.io/tags/js%E5%8E%9F%E5%9E%8B%E9%93%BE/"/>
    
  </entry>
  
  <entry>
    <title>MongoDB下载、安装与部署</title>
    <link href="https://smiletolove.github.io/2018/09/01/MongoDB%E4%B8%8B%E8%BD%BD%E3%80%81%E5%AE%89%E8%A3%85%E4%B8%8E%E9%83%A8%E7%BD%B2/"/>
    <id>https://smiletolove.github.io/2018/09/01/MongoDB下载、安装与部署/</id>
    <published>2018-09-01T14:41:34.000Z</published>
    <updated>2019-03-05T05:56:50.349Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、MongoDB的下载、安装与部署"><a href="#一、MongoDB的下载、安装与部署" class="headerlink" title="一、MongoDB的下载、安装与部署"></a>一、MongoDB的下载、安装与部署</h2><p>1、什么是MongoDB？</p><p>　　它是介于关系型数据库和非关系型数据库之间的一种NoSQL数据库，用C++编写，是一款集敏捷性、可伸缩性、扩展性于一身的高性能的面向文档的通用数据库。<br><a id="more"></a></p><h2 id="2、为什么要用MongoDB？"><a href="#2、为什么要用MongoDB？" class="headerlink" title="2、为什么要用MongoDB？"></a>2、为什么要用MongoDB？</h2><p>　　它具有以下几个特征：</p><p>　　　　a）、灵活的文档数据模型</p><p>　　　　　　　　可以非常容易的存储不同结构的的数据，并且还能动态的修改这些数据的源结构模式</p><p>　　　　b）、可伸缩可扩展性</p><p>　　　　　　　　从单个服务器到数千个节点，MongoDB可以很轻松的进行水平扩展，部署多个数据中心</p><p>　　　　c）、二级索引</p><p>　　　　　　　　包括在完全一致的任何字段上的索引、地理空间、文本搜索以及TTL索引，都能进行快速、细粒度的访问到数据</p><p>　　　　d）、丰富的查询语言</p><p>　　　　　　　　MongoDB的查询语言提供了多样化的字段级别的操作符、数据类型以及即时更新。几乎提供了所有编程语言的驱动来更直观的使用它</p><p>　　　　e）、健壮的操作工具</p><p>　　　　　　　　MongoDB的管理服务和运维管理工具可以使你很轻松的部署，监控、备份和规划它</p><h2 id="3、什么时候用MongoDB？"><a href="#3、什么时候用MongoDB？" class="headerlink" title="3、什么时候用MongoDB？"></a>3、什么时候用MongoDB？</h2><p>　　以下几个使用场合：</p><p>　　　　a）、需要写入大量的数据，但是这些这些数据的价值并不是太高，比如：日志</p><p>　　　　b）、数据增长量较大，而且数据结构有时候还不一致</p><p>　　　　c）、未来数据会很大</p><h2 id="4、MongoDB的安装部署"><a href="#4、MongoDB的安装部署" class="headerlink" title="4、MongoDB的安装部署"></a>4、MongoDB的安装部署</h2><p>　　下载地址：<a href="http://www.mongodb.org/downloads，注意有32位和64位之分，32为数据库最大容量不能超过2GB！" target="_blank" rel="noopener">http://www.mongodb.org/downloads，注意有32位和64位之分，32为数据库最大容量不能超过2GB！</a></p><p>　　博主系统是Win8.1 64位系统，所以以下是以此系统为例进行最新版本（3.03）的MongoDB的安装和部署！</p><p>　　　　a）、下载好64位的MSI安装文件，双击进行安装。</p><p>　　　　　　　　Ⅰ、直接Next进入下一步：<br>                 <img src="/css/images/m1.jpg" alt></p><p>　　　　　　　　Ⅱ、勾选“I accept……”，你懂的、Next：</p><p>　　　　　　　　Ⅲ、第一个选项：Complete（完整版），默认安装所有功能到C盘；第二个选项Custom（自定义），可以选择安装目录与服务。这里我们选择Custom：</p><p>　　　　　　　　Ⅳ、默认全部功能安装，选择Browse更换安装目录到F:\MongoDB（自己选择、）下，Next，然后选择Install开始安装：</p><p>　　　　　　　　Ⅴ、安装完成！</p><p>　　　　　　　　Ⅶ、打开MongoDB目录下的bin文件夹，你会看到很多exe可执行文件，简单介绍下：<br>      <img src="/css/images/m2.jpg" alt></p><p>　　　　b）、开始部署：</p><p>　　　　　　　　Ⅰ、首先我们在安装目录（F:\MongoDB）下新建一个db文件夹作为数据库存放路径，然后用服务端文件指定为数据库目录！</p><p>　　　　　　　　　　　　win+R，输入cmd，进入DOS命令窗口，然后用cd命令进入F:\MongoDB:\bin目录下，执行如下命令：</p><p>　　　　　　　　　　　　　　F:\MongoDB\bin&gt;mongod.exe –dbpath F:\MongoDB\db</p><p>　　　　　　　　　　将会输出服务端相关信息，包括版本，数据库所在路径，监听端口号，数据库大小等等、看到这个说明你已经成功了、<br><img src="/css/images/m3.jpg" alt></p><p>　　　　　　　　　　或者在浏览器中输入：<a href="http://localhost:27017/，你会看到下面一段话，" target="_blank" rel="noopener">http://localhost:27017/，你会看到下面一段话，</a></p><p>　　　　　　　　　　　It looks like you are trying to access MongoDB over HTTP on the native driver port.<br>　　　　　　　　　　“正在尝试在本地驱动端口上用HTTP链接MongoDB”，也能说明你配置服务端成功了！</p><p>　　　　　　　　Ⅱ、启动MongoDB客户端进入shell、</p><p>　　　　　　　　　　　　服务端配置成功之后，我们不要关闭这个服务端DOS窗口，否则的话是无法连接的！</p><p>　　　　　　　　　　　　我们打开另外一个命令窗口，进入到F:\MongoDB:\bin下，输入mongo.exe命令连接数据库<br><img src="/css/images/m4.jpg" alt></p><p>　　　　　　　　　　　　看到这个说明客户端已经成功连接服务器，接下来你就可以在shell中使用各式各样的mongodb命令了！！</p><p>　　　　　　　　　　　　如果服务端没有开启的话，会出现如下无法连接的错误：<br><img src="/css/images/m5.jpg" alt></p><p>　　　　c）、为系统添加MongoDB服务</p><p>　　　　　　　　到这一步那么会有人说了，我总不能每次使用客户端的时候都要保持一个服务端的DOS窗口为打开状态吧？答案当然是肯定不会的了！</p><p>　　　　　　　　下面我们就试着添加一个MongoDB服务：</p><p>　　　　　　　　Ⅰ、我们在F:\MongoDB目录下新建一个log文件夹用于存放日志文件，然后组合键 win+x+a，打开管理员命令提示符。</p><p>　　　　　　　　Ⅱ、使用如下命令创建配置文件mongod.cfg：</p><p>C:\Windows\system32&gt;echo logpath=F:\MongoDB\log\mongod.log&gt; “F:\MongoDB\mongod.cfg”</p><p>C:\Windows\system32&gt;echo dbpath=F:\MongoDB\db&gt;&gt; “F:\MongoDB\mongod.cfg”</p><p>　　　　　　　　Ⅲ、好了，准备工作已经做完，下面开始最重要的一步，使用SC命令创建MongoDB服务：</p><pre><code> 　　C:\Windows\system32&gt;sc.exe create MongoDB binpath=&quot;F:\MongoDB\bin\mongod.exe --service --config=F:\MongoDB\mongod.cfg&quot;</code></pre><p>　　　　　　　　　　之后会出现以下创建服务成功提示：<br>                  <img src="/css/images/m6.jpg" alt>　　　　　　　　　　　　　　　　　　　　</p><p>　　　　　　　　Ⅳ、开启服务：</p><p>　　　　　　　　　　　　使用如下命令：C:\Windows\system32&gt;net start MongoDB 开启MongoDB服务！看到这个说明你成功了、<br>                   <img src="/css/images/m7.jpg" alt></p><p>　　　　　　　　　　　　然后win+r，输入services.msc打开windows服务列表，你会看到一个名称为MongoDB，状态为“正在运行”的服务、<br>                   <img src="/css/images/m8.jpg" alt></p><p>　　　　　　　　　　　　到此为止你就可以从服务中启动MongoDB，然后使用它的服务而不用一直保留着另一个服务端的DOS窗口了！</p><p>　　　　　　　　Ⅴ、关闭服务和删除服务</p><p>　　　　　　　　　　　　关闭服务使用如下命令：</p><p>　　　　　　　　　　　　　　　　　　C:\Windows\system32&gt;net stop MongoDB</p><p>　　　　　　　　　　　　删除服务使用如下命令：</p><p>　　　　　　　　　　　　　　　　　　C:\Windows\system32&gt;sc.exe delete MongoDB</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、MongoDB的下载、安装与部署&quot;&gt;&lt;a href=&quot;#一、MongoDB的下载、安装与部署&quot; class=&quot;headerlink&quot; title=&quot;一、MongoDB的下载、安装与部署&quot;&gt;&lt;/a&gt;一、MongoDB的下载、安装与部署&lt;/h2&gt;&lt;p&gt;1、什么是MongoDB？&lt;/p&gt;
&lt;p&gt;　　它是介于关系型数据库和非关系型数据库之间的一种NoSQL数据库，用C++编写，是一款集敏捷性、可伸缩性、扩展性于一身的高性能的面向文档的通用数据库。&lt;br&gt;
    
    </summary>
    
      <category term="MongoDB" scheme="https://smiletolove.github.io/categories/MongoDB/"/>
    
    
      <category term="MongoDB" scheme="https://smiletolove.github.io/tags/MongoDB/"/>
    
  </entry>
  
  <entry>
    <title>jQuery事件委托</title>
    <link href="https://smiletolove.github.io/2018/05/02/jQuery%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98/"/>
    <id>https://smiletolove.github.io/2018/05/02/jQuery事件委托/</id>
    <published>2018-05-01T16:07:27.000Z</published>
    <updated>2019-03-05T05:58:08.182Z</updated>
    
    <content type="html"><![CDATA[<h2 id="JavaScript-jQuery-中的事件委托"><a href="#JavaScript-jQuery-中的事件委托" class="headerlink" title="JavaScript(jQuery)中的事件委托"></a>JavaScript(jQuery)中的事件委托</h2><p>一：什么是事件委托？</p><p>事件委托是利用事件冒泡，只指定一个事件处理程序来管理某一类型的所有事件。<image src="/css/images/表情/打牌.gif" style="display:block;margin:40px auto 0;"><a id="more"></a></image></p><p>二：为什么要用事件委托？</p><p>1.在JavaScript中添加到页面上的事件处理程序的个数直接关系到页面的整体运行性能。为什么呢？因为，每个事件处理函数都是对象，对象会占用内存，内存中的对象越多，性能就越差。此外，必须事先指定所有的事件处理程序而导致的DOM访问次数，会延迟整个页面的交互就绪时间。</p><p>2.对有很多个数据的表格以及很长的列表逐个添加事件，简直就是噩梦。所以事件委托，能极大地提高页面的运行性能，减少开发人员的工作量。</p><p>三：JavaScript中的例子</p><p>我们以下面的HTML代码为例，用事件委托的方式实现当鼠标单击某个li元素的时候，li元素的背景变成红色。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul id = <span class="string">"lists"</span>&gt;</span><br><span class="line">         &lt;li&gt;列表1&lt;/li&gt;</span><br><span class="line">         &lt;li&gt;列表2&lt;/li&gt;</span><br><span class="line">         &lt;li&gt;列表3&lt;/li&gt;</span><br><span class="line">         &lt;li&gt;列表4&lt;/li&gt;</span><br><span class="line">         &lt;li&gt;列表5&lt;/li&gt;</span><br><span class="line">         &lt;li&gt;列表6&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure></p><p> 下面是JavaScript代码：</p><pre><code> var lists = document.getElementById(&quot;lists&quot;); lists.addEventListener(&quot;click&quot;,function(event){     var target = event.target;     //防止父元素ul也触发事件     if(target.nodeName == &quot;LI&quot;){        target.style.backgroundColor = &quot;red&quot;;     }})</code></pre><p>单击列表4，实现效果：<br><img src="/css/images/jQuery/委托1.jpg" alt><br><img src="/css/images/jQuery/委托2.jpg" alt><br>未单击之前单击列表4之后</p><p> 三：jQuery中的例子<br>jQuery中的事件委托方式比较丰富，就以同样的例子来说：<br>1、用on方法,代码如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">           $(<span class="string">"#lists"</span>).on(<span class="string">"click"</span>,<span class="string">"li"</span>,<span class="keyword">function</span>(event)&#123;</span><br><span class="line">               var target = $(event.target);</span><br><span class="line">               target.css(<span class="string">"background-color"</span>,<span class="string">"red"</span>);</span><br><span class="line">           &#125;)</span><br><span class="line">       &#125;)</span><br></pre></td></tr></table></figure><p>2.用delegate（）方法，代码如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">    $(<span class="string">"#lists"</span>).delegate(<span class="string">"li"</span>,<span class="string">"click"</span>,<span class="keyword">function</span>(event)&#123;                 var target = $(event.target);</span><br><span class="line">        target.css(<span class="string">"background-color"</span>,<span class="string">"red"</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>on()方法和delegate（）方法对于事件委托的写法很像。并且执行事件委托的时候只有子元素（本文中的li）会触发事件，而代为执行的父元素（本文中为ul）不会触发事件，所以我们不需要盘判断触发事件的元素节点名，这一点明显优于原生的JavaScript。</p><p>3.用bind()方法，代码如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">     $(<span class="string">"#lists"</span>).<span class="built_in">bind</span>(<span class="string">"click"</span>,<span class="string">"li"</span>,<span class="keyword">function</span>(event)&#123;</span><br><span class="line">         var target = $(event.target);</span><br><span class="line">         <span class="keyword">if</span>(target.prop(<span class="string">"nodeName"</span>)==<span class="string">"LI"</span>)&#123;</span><br><span class="line">        target.css(<span class="string">"background-color"</span>,<span class="string">"red"</span>);&#125;</span><br><span class="line">    &#125;)</span><br><span class="line"> &#125;)</span><br></pre></td></tr></table></figure></p><p>bind()方法同原生的JavaScript实现方法一样，当父元素代子元素执行事件时，父元素也会触发事件，所以我们需要判断一下触发事件的元素名。此外，用bind()方法给元素绑定事件的时候要注意，它只能给已经存在DOM元素添加事件，不能给未来存在DOM</p><p>元素添加添加事件。如果要频繁地添加DOM元素，并且给新添加的DOM元素绑定事件的话，用live(),delegate(),on()等方法。鉴于jQuery从1.7之后就不推荐live（）和delegate（）方法了，所以大家还是使用on（）方法吧。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;JavaScript-jQuery-中的事件委托&quot;&gt;&lt;a href=&quot;#JavaScript-jQuery-中的事件委托&quot; class=&quot;headerlink&quot; title=&quot;JavaScript(jQuery)中的事件委托&quot;&gt;&lt;/a&gt;JavaScript(jQuery)中的事件委托&lt;/h2&gt;&lt;p&gt;一：什么是事件委托？&lt;/p&gt;
&lt;p&gt;事件委托是利用事件冒泡，只指定一个事件处理程序来管理某一类型的所有事件。&lt;image src=&quot;/css/images/表情/打牌.gif&quot; style=&quot;display:block;margin:40px auto 0;&quot;&gt;
    
    </summary>
    
      <category term="jQuery" scheme="https://smiletolove.github.io/categories/jQuery/"/>
    
    
      <category term="jQuery事件委托" scheme="https://smiletolove.github.io/tags/jQuery%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98/"/>
    
  </entry>
  
  <entry>
    <title>jQuery选择器总结</title>
    <link href="https://smiletolove.github.io/2017/11/02/jQuery%E9%80%89%E6%8B%A9%E5%99%A8%E6%80%BB%E7%BB%93/"/>
    <id>https://smiletolove.github.io/2017/11/02/jQuery选择器总结/</id>
    <published>2017-11-01T16:25:14.000Z</published>
    <updated>2019-03-05T05:56:06.860Z</updated>
    
    <content type="html"><![CDATA[<p>jQuery选择器总结<br>jQuery 的选择器可谓之强大无比，这里简单地总结一下常用的元素查找方法<a id="more"></a></p><p>$(“#myELement”)    选择id值等于myElement的元素，id值不能重复在文档中只能有一个id值是myElement所以得到的是唯一的元素<br>$(“div”)           选择所有的div标签元素，返回div元素数组<br>$(“.myClass”)      选择使用myClass类的css的所有元素<br>$(“*”)             选择文档中的所有的元素，可以运用多种的选择方式进行联合选择：例如$(“#myELement,div,.myclass”) </p><p>层叠选择器：<br>$(“form input”)         选择所有的form元素中的input元素<br>$(“#main &gt; *”)          选择id值为main的所有的子元素<br>$(“label + input”)     选择所有的label元素的下一个input元素节点，经测试选择器返回的是label标签后面直接跟一个input标签的所有input标签元素<br>$(“#prev ~ div”)       同胞选择器，该选择器返回的为id为prev的标签元素的所有的属于同一个父元素的div标签 </p><p>基本过滤选择器：<br>$(“tr:first”)               选择所有tr元素的第一个<br>$(“tr:last”)                选择所有tr元素的最后一个<br>$(“input:not(:checked) + span”)   </p><p>过滤掉：checked的选择器的所有的input元素 </p><p>$(“tr:even”)               选择所有的tr元素的第0，2，4… …个元素（注意：因为所选择的多个元素时为数组，所以序号是从0开始） </p><p>$(“tr:odd”)                选择所有的tr元素的第1，3，5… …个元素<br>$(“td:eq(2)”)             选择所有的td元素中序号为2的那个td元素<br>$(“td:gt(4)”)             选择td元素中序号大于4的所有td元素<br>$(“td:ll(4)”)              选择td元素中序号小于4的所有的td元素<br>$(“:header”)<br>$(“div:animated”)<br>内容过滤选择器： </p><p>$(“div:contains(‘John’)”) 选择所有div中含有John文本的元素<br>$(“td:empty”)           选择所有的为空（也不包括文本节点）的td元素的数组<br>$(“div:has(p)”)        选择所有含有p标签的div元素<br>$(“td:parent”)          选择所有的以td为父节点的元素数组<br>可视化过滤选择器： </p><p>$(“div:hidden”)        选择所有的被hidden的div元素<br>$(“div:visible”)        选择所有的可视化的div元素<br>属性过滤选择器： </p><p>$(“div[id]”)              选择所有含有id属性的div元素<br>$(“input[name=’newsletter’]”)    选择所有的name属性等于’newsletter’的input元素 </p><p>$(“input[name!=’newsletter’]”) 选择所有的name属性不等于’newsletter’的input元素 </p><p>$(“input[name^=’news’]”)         选择所有的name属性以’news’开头的input元素<br>$(“input[name$=’news’]”)         选择所有的name属性以’news’结尾的input元素<br>$(“input[name*=’man’]”)          选择所有的name属性包含’news’的input元素 </p><p>$(“input[id][name$=’man’]”)    可以使用多个属性进行联合选择，该选择器是得到所有的含有id属性并且那么属性以man结尾的元素 </p><p>子元素过滤选择器： </p><p>$(“ul li:nth-child(2)”),$(“ul li:nth-child(odd)”),$(“ul li:nth-child(3n + 1)”) </p><p>$(“div span:first-child”)          返回所有的div元素的第一个子节点的数组<br>$(“div span:last-child”)           返回所有的div元素的最后一个节点的数组<br>$(“div button:only-child”)       返回所有的div中只有唯一一个子节点的所有子节点的数组 </p><p>表单元素选择器： </p><p>$(“:input”)                  选择所有的表单输入元素，包括input, textarea, select 和 button </p><p>$(“:text”)                     选择所有的text input元素<br>$(“:password”)           选择所有的password input元素<br>$(“:radio”)                   选择所有的radio input元素<br>$(“:checkbox”)            选择所有的checkbox input元素<br>$(“:submit”)               选择所有的submit input元素<br>$(“:image”)                 选择所有的image input元素<br>$(“:reset”)                   选择所有的reset input元素<br>$(“:button”)                选择所有的button input元素<br>$(“:file”)                     选择所有的file input元素<br>$(“:hidden”)               选择所有类型为hidden的input元素或表单的隐藏域 </p><p>表单元素过滤选择器： </p><p>$(“:enabled”)             选择所有的可操作的表单元素<br>$(“:disabled”)            选择所有的不可操作的表单元素<br>$(“:checked”)            选择所有的被checked的表单元素<br>$(“select option:selected”) 选择所有的select 的子元素中被selected的元素 </p><p>选取一个 name 为”S_03_22″的input text框的上一个td的text值<br>$(”input[@ name =S_03_22]“).parent().prev().text() </p><p>名字以”S_”开始，并且不是以”<em>R”结尾的<br>$(”input[@ name ^=’S</em>‘]“).not(”[@ name $=’_R’]“) </p><p>一个名为 radio_01的radio所选的值<br>$(”input[@ name =radio_01][@checked]“).val(); </p><p>$(“A B”) 查找A元素下面的所有子节点，包括非直接子节点<br>$(“A&gt;B”) 查找A元素下面的直接子节点<br>$(“A+B”) 查找A元素后面的兄弟节点，包括非直接子节点<br>$(“A~B”) 查找A元素后面的兄弟节点，不包括非直接子节点 </p><ol><li>$(“A B”) 查找A元素下面的所有子节点，包括非直接子节点 </li></ol><p>例子：找到表单中所有的 input 元素 </p><p>HTML 代码:<br> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;form&gt;</span><br><span class="line">&lt;label&gt;Name:&lt;/label&gt;</span><br><span class="line">&lt;input name=<span class="string">"name"</span> /&gt;</span><br><span class="line">&lt;fieldset&gt;</span><br><span class="line">      &lt;label&gt;Newsletter:&lt;/label&gt;</span><br><span class="line">      &lt;input name=<span class="string">"newsletter"</span> /&gt;</span><br><span class="line">&lt;/fieldset&gt;</span><br><span class="line">&lt;/form&gt;</span><br><span class="line">&lt;input name=<span class="string">"none"</span> /&gt; </span><br><span class="line">jQuery 代码:</span><br></pre></td></tr></table></figure></p><p>$(“form input”)<br>结果: </p><p><input name="name">, <input name="newsletter"></p><ol start="2"><li>$(“A&gt;B”) 查找A元素下面的直接子节点<br>例子：匹配表单中所有的子级input元素。 </li></ol><p>HTML 代码:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;form&gt;</span><br><span class="line">&lt;label&gt;Name:&lt;/label&gt;</span><br><span class="line">&lt;input name=<span class="string">"name"</span> /&gt;</span><br><span class="line">&lt;fieldset&gt;</span><br><span class="line">      &lt;label&gt;Newsletter:&lt;/label&gt;</span><br><span class="line">      &lt;input name=<span class="string">"newsletter"</span> /&gt;</span><br><span class="line">&lt;/fieldset&gt;</span><br><span class="line">&lt;/form&gt;</span><br><span class="line">&lt;input name=<span class="string">"none"</span> /&gt; </span><br><span class="line">jQuery 代码:</span><br></pre></td></tr></table></figure></p><p>$(“form &gt; input”)<br>结果: </p><input name="name"> <ol start="3"><li>$(“A+B”) 查找A元素后面的兄弟节点，包括非直接子节点<br>例子：匹配所有跟在 label 后面的 input 元素 </li></ol><p>HTML 代码:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&lt;form&gt;</span><br><span class="line">&lt;label&gt;Name:&lt;/label&gt;</span><br><span class="line">&lt;input name=<span class="string">"name"</span> /&gt;</span><br><span class="line">&lt;fieldset&gt;</span><br><span class="line">      &lt;label&gt;Newsletter:&lt;/label&gt;</span><br><span class="line">      &lt;input name=<span class="string">"newsletter"</span> /&gt;</span><br><span class="line">&lt;/fieldset&gt;</span><br><span class="line">&lt;/form&gt;</span><br><span class="line">&lt;input name=<span class="string">"none"</span> /&gt; </span><br><span class="line">jQuery 代码: </span><br><span class="line">``` </span><br><span class="line">$(<span class="string">"label + input"</span>) </span><br><span class="line">结果: </span><br><span class="line"> </span><br><span class="line">&lt;input name=<span class="string">"name"</span> /&gt;, &lt;input name=<span class="string">"newsletter"</span> /&gt; </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">4. $(<span class="string">"A~B"</span>) 查找A元素后面的兄弟节点，不包括非直接子节点 </span><br><span class="line">例子：找到所有与表单同辈的 input 元素 </span><br><span class="line"> </span><br><span class="line">HTML 代码: </span><br><span class="line">```bash </span><br><span class="line">&lt;form&gt;</span><br><span class="line">&lt;label&gt;Name:&lt;/label&gt;</span><br><span class="line">&lt;input name=<span class="string">"name"</span> /&gt;</span><br><span class="line">&lt;fieldset&gt;</span><br><span class="line">      &lt;label&gt;Newsletter:&lt;/label&gt;</span><br><span class="line">      &lt;input name=<span class="string">"newsletter"</span> /&gt;</span><br><span class="line">&lt;/fieldset&gt;</span><br><span class="line">&lt;/form&gt;</span><br><span class="line">&lt;input name=<span class="string">"none"</span> /&gt;</span><br></pre></td></tr></table></figure></p><p>jQuery 代码:<br>$(“form ~ input”)<br>结果: </p><input name="none"> ]]></content>
    
    <summary type="html">
    
      &lt;p&gt;jQuery选择器总结&lt;br&gt;jQuery 的选择器可谓之强大无比，这里简单地总结一下常用的元素查找方法
    
    </summary>
    
      <category term="jQuery" scheme="https://smiletolove.github.io/categories/jQuery/"/>
    
    
      <category term="jQuery选择器" scheme="https://smiletolove.github.io/tags/jQuery%E9%80%89%E6%8B%A9%E5%99%A8/"/>
    
  </entry>
  
</feed>
